{-# OPTIONS --without-K #-}

module cwfs.Contextual where

open import cwfs.CwFs

record LenStructure {ℓₒ ℓₘ} {C : WildCategory ℓₒ ℓₘ} (cwfstr : CwFStructure C)
  : Type (lsuc (ℓₒ l⊔ ℓₘ)) where

  open CwFStructure cwfstr

  field
    len : Con → ℕ
    len-∷ : (Γ : Con) (A : Ty Γ) → len (Γ ∷ A) == 1+ (len Γ)

  ∷-len : ∀ n → Σ[ Γ ∶ Con ] Ty Γ × (len Γ == n) → Σ[ Γ ∶ Con ] len Γ == 1+ n
  ∷-len _ (Γ , A , idp) = (Γ ∷ A) , len-∷ Γ A

record ContextualStructure {ℓₒ ℓₘ} {C : WildCategory ℓₒ ℓₘ} (cwfstr : CwFStructure C)
  : Type (lsuc (ℓₒ l⊔ ℓₘ)) where

  field lenstr : LenStructure cwfstr
  open LenStructure lenstr
  open CwFStructure cwfstr

  field
    len-◆-equiv : ∀ {Γ} → (Γ == ◆) ≃ (len Γ == O)
      -- Do we actually need it to be this strong?
      -- What about just (len ◆ == O) × (len Γ == O → Γ == ◆)?
    len-∷-equiv : ∀ {n} → is-equiv (∷-len n)

  len-◆ : len ◆ == O
  len-◆ = –> len-◆-equiv idp

  module _ {n} (Γ : Con) (p : len Γ == 1+ n) where
    split : Σ[ Δ ∶ Con ] Ty Δ
    split = first-two (inv-equiv len-∷-equiv (Γ , p))

module Contextual-contextual-core {ℓₒ ℓₘ} {C : WildCategory ℓₒ ℓₘ} (cwf : CwFStructure C)
  where

  -- Given a CwF 𝒞, the sub-CwF on the contexts generated by ◆ and
  -- ∷ is a contextual CwF. We call this the *contextual core* of 𝒞.

  open CwFStructure cwf

  module _ where
    listlike : ℕ → Type ℓₒ
    con-of : {n : ℕ} → listlike n → Con

    listlike O = Lift ⊤
    listlike (1+ n) = Σ[ γ ∶ listlike n ] Ty (con-of γ)

    con-of {O} _ = ◆
    con-of {1+ n} (γ , A) = con-of γ ∷ A

  -- (Isomorphic to the) Subcategory of C inductively generated by ◆ and ∷
  Cᶜ : WildCategory ℓₒ ℓₘ
  WildCategory.Ob Cᶜ = Σ[ n ∶ ℕ ] listlike n
  WildCategory.wildcatstr Cᶜ = record
    { wildsemicatstr = record
        { hom = λ{ (_ , γ) (_ , δ) → Sub (con-of γ) (con-of δ) }
        ; _◦_ = _◦_
        ; ass = ass }
    ; id = id
    ; idl = idl
    ; idr = idr }

  ctxstrᶜ : ContextStructure Cᶜ
  ctxstrᶜ = record
    { ◆ = O , lift unit
    ; ◆-terminal = λ{ (_ , γ) → ◆-terminal (con-of γ) } }

  open ContextStructure ctxstrᶜ

  tytmstrᶜ : TyTmStructure Cᶜ
  tytmstrᶜ = record
    { ctxstr = ctxstrᶜ
    ; Ty = λ{ (_ , γ) → Ty (con-of γ) }
    ; _[_] = _[_]
    ; [id] = [id]
    ; [◦] = [◦]
    ; Tm = Tm
    ; _[_]ₜ = _[_]ₜ
    ; [id]ₜ = [id]ₜ
    ; [◦]ₜ = [◦]ₜ }

  coeᵀᵐᶜ= :
    {Γ @ (n , γ) : ContextStructure.Con ctxstrᶜ}
    {A A' : Ty (con-of γ)}
    (p : A == A') (t : Tm A)
    → TyTmStructure.coeᵀᵐ tytmstrᶜ {Γ} p t == coeᵀᵐ p t
  coeᵀᵐᶜ= idp t = idp

  cwfstrᶜ : CwFStructure Cᶜ
  CwFStructure.compstr cwfstrᶜ = record
    { tytmstr = tytmstrᶜ
    ; _∷_ = λ (n , γ) A → 1+ n , γ , A
    ; π = π
    ; υ = υ
    ; _,,_ = _,,_
    ; βπ = βπ
    ; βυ = βυ
    ; η,, = η,,
    ; ,,-◦ = ,,-◦ ∙ ⟨=,, ! (coeᵀᵐᶜ= (! [◦]) _) =⟩ }

  lenstrᶜ : LenStructure cwfstrᶜ
  LenStructure.len lenstrᶜ = fst
  LenStructure.len-∷ lenstrᶜ Γ A = idp

  ContextualCoreStructure : ContextualStructure cwfstrᶜ
  ContextualStructure.lenstr ContextualCoreStructure = lenstrᶜ
  ContextualStructure.len-◆-equiv ContextualCoreStructure =
    equiv (λ{ idp → idp }) (λ{ idp → idp }) (λ{ idp → idp }) (λ{ idp → idp })
  ContextualStructure.len-∷-equiv ContextualCoreStructure {n} =
    is-eq (∷-len n)
      (λ{ ((_ , γ , A) , idp) → (n , γ) , A , idp })
      (λ{ ((_ , γ) , idp) → idp })
      (λ{ ((_ , γ) , A , idp) → idp })
    where open LenStructure lenstrᶜ using (∷-len)
